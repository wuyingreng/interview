<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tree.js Demo</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      text-align: center;
    }

    .content {
      padding: 20px;
    }

    .controls {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-primary:hover {
      background: #0056b3;
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn-success:hover {
      background: #1e7e34;
    }

    .btn-warning {
      background: #ffc107;
      color: #212529;
    }

    .btn-warning:hover {
      background: #e0a800;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-danger:hover {
      background: #c82333;
    }

    .info-panel {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .info-panel h4 {
      margin-top: 0;
      color: #495057;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: white;
      border: 1px solid #e9ecef;
      border-radius: 5px;
      padding: 15px;
      text-align: center;
    }

    .stat-number {
      font-size: 24px;
      font-weight: bold;
      color: #007bff;
    }

    .stat-label {
      color: #6c757d;
      font-size: 14px;
    }

    #tree-container {
      width: 100%;
      height: 600px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      background: #fafafa;
    }

    .log {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      padding: 15px;
      margin-top: 20px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }

    .log-entry {
      margin-bottom: 5px;
      padding: 2px 0;
    }

    .log-info {
      color: #007bff;
    }

    .log-success {
      color: #28a745;
    }

    .log-warning {
      color: #ffc107;
    }

    .log-error {
      color: #dc3545;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ğŸŒ³ Tree.js Demo</h1>
      <p>åŸºäºThree.jsçš„3Dæ ‘å½¢ç»“æ„å¯è§†åŒ–æ¼”ç¤º</p>
    </div>

    <div class="content">
      <div class="info-panel">
        <h4>ğŸ“‹ åŠŸèƒ½è¯´æ˜</h4>
        <p>è¿™æ˜¯ä¸€ä¸ªåŸºäºThree.jsçš„3Dæ ‘å½¢ç»“æ„å¯è§†åŒ–æ¼”ç¤ºï¼Œæ”¯æŒåŠ¨æ€æ·»åŠ èŠ‚ç‚¹ã€åˆ é™¤èŠ‚ç‚¹ã€æœç´¢èŠ‚ç‚¹ç­‰åŠŸèƒ½ã€‚</p>
      </div>

      <div class="stats">
        <div class="stat-card">
          <div class="stat-number" id="nodeCount">0</div>
          <div class="stat-label">èŠ‚ç‚¹æ•°é‡</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="levelCount">0</div>
          <div class="stat-label">å±‚çº§æ·±åº¦</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="selectedNode">-</div>
          <div class="stat-label">é€‰ä¸­èŠ‚ç‚¹</div>
        </div>
      </div>

      <div class="controls">
        <button class="btn btn-primary" onclick="addRandomNode()">ğŸ² æ·»åŠ éšæœºèŠ‚ç‚¹</button>
        <button class="btn btn-success" onclick="addChildNode()">â• æ·»åŠ å­èŠ‚ç‚¹</button>
        <button class="btn btn-warning" onclick="searchNode()">ğŸ” æœç´¢èŠ‚ç‚¹</button>
        <button class="btn btn-danger" onclick="deleteNode()">ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹</button>
        <button class="btn btn-primary" onclick="resetTree()">ğŸ”„ é‡ç½®æ ‘</button>
        <button class="btn btn-success" onclick="exportTree()">ğŸ’¾ å¯¼å‡ºæ ‘</button>
      </div>

      <div id="tree-container"></div>

      <div class="log" id="log">
        <div class="log-entry log-info">ğŸš€ Tree.js Demo åˆå§‹åŒ–å®Œæˆ</div>
      </div>
    </div>
  </div>

  <!-- å¼•å…¥Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- å¼•å…¥OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // å…¨å±€å˜é‡
    let scene, camera, renderer, controls;
    let treeNodes = [];
    let selectedNode = null;
    let nodeIdCounter = 0;
    let logContainer;

    // èŠ‚ç‚¹ç±»
    class TreeNode {
      constructor(id, name, parent = null) {
        this.id = id;
        this.name = name;
        this.parent = parent;
        this.children = [];
        this.position = { x: 0, y: 0, z: 0 };
        this.mesh = null;
        this.level = parent ? parent.level + 1 : 0;
      }

      addChild(child) {
        this.children.push(child);
        child.parent = this;
        child.level = this.level + 1;
      }

      removeChild(child) {
        const index = this.children.indexOf(child);
        if (index > -1) {
          this.children.splice(index, 1);
          child.parent = null;
        }
      }
    }

    // åˆå§‹åŒ–Three.jsåœºæ™¯
    function initThreeJS() {
      // åˆ›å»ºåœºæ™¯
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // åˆ›å»ºç›¸æœº
      camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
      camera.position.set(0, 10, 20);

      // åˆ›å»ºæ¸²æŸ“å™¨
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(800, 600);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // æ·»åŠ åˆ°å®¹å™¨
      document.getElementById('tree-container').appendChild(renderer.domElement);

      // åˆ›å»ºæ§åˆ¶å™¨
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // æ·»åŠ å…‰æº
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // æ·»åŠ åœ°é¢
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      logContainer = document.getElementById('log');
    }

    // åˆ›å»ºèŠ‚ç‚¹ç½‘æ ¼
    function createNodeMesh(node, isSelected = false) {
      const geometry = new THREE.SphereGeometry(0.5, 16, 16);
      const material = new THREE.MeshLambertMaterial({
        color: isSelected ? 0xff6b6b : (node.level === 0 ? 0x4ecdc4 : 0x45b7d1)
      });
      const mesh = new THREE.Mesh(geometry, material);

      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { node: node };

      return mesh;
    }

    // åˆ›å»ºè¿æ¥çº¿
    function createConnectionLine(parent, child) {
      const points = [
        new THREE.Vector3(parent.position.x, parent.position.y, parent.position.z),
        new THREE.Vector3(child.position.x, child.position.y, child.position.z)
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0x666666 });
      return new THREE.Line(geometry, material);
    }

    // æ›´æ–°æ ‘çš„ä½ç½®
    function updateTreePositions() {
      if (treeNodes.length === 0) return;

      // ç®€å•çš„æ ‘å½¢å¸ƒå±€ç®—æ³•
      const root = treeNodes[0];
      if (!root) return;

      // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„ä½ç½®
      function calculatePositions(node, x = 0, y = 0, z = 0) {
        node.position = { x, y, z };

        if (node.children.length > 0) {
          const childSpacing = 3;
          const startX = x - (node.children.length - 1) * childSpacing / 2;

          node.children.forEach((child, index) => {
            const childX = startX + index * childSpacing;
            const childY = y - 2;
            calculatePositions(child, childX, childY, z);
          });
        }
      }

      calculatePositions(root, 0, 8, 0);

      // æ›´æ–°ç½‘æ ¼ä½ç½®
      treeNodes.forEach(node => {
        if (node.mesh) {
          node.mesh.position.set(node.position.x, node.position.y, node.position.z);
        }
      });

      // é‡æ–°åˆ›å»ºè¿æ¥çº¿
      scene.children = scene.children.filter(child => !(child instanceof THREE.Line));

      treeNodes.forEach(node => {
        if (node.parent && node.mesh) {
          const line = createConnectionLine(node.parent, node);
          scene.add(line);
        }
      });
    }

    // æ·»åŠ èŠ‚ç‚¹
    function addNode(name, parent = null) {
      const node = new TreeNode(++nodeIdCounter, name, parent);
      treeNodes.push(node);

      if (parent) {
        parent.addChild(node);
      }

      // åˆ›å»ºç½‘æ ¼
      node.mesh = createNodeMesh(node);
      scene.add(node.mesh);

      // æ›´æ–°ä½ç½®
      updateTreePositions();

      // æ›´æ–°ç»Ÿè®¡
      updateStats();

      log(`âœ… æ·»åŠ èŠ‚ç‚¹: ${name} (ID: ${node.id})`);
    }

    // æ·»åŠ éšæœºèŠ‚ç‚¹
    function addRandomNode() {
      const names = ['Node', 'Leaf', 'Branch', 'Root', 'Tree', 'Data', 'Info', 'Item'];
      const randomName = names[Math.floor(Math.random() * names.length)] + Math.floor(Math.random() * 100);

      if (treeNodes.length === 0) {
        addNode(randomName);
      } else {
        const randomParent = treeNodes[Math.floor(Math.random() * treeNodes.length)];
        addNode(randomName, randomParent);
      }
    }

    // æ·»åŠ å­èŠ‚ç‚¹
    function addChildNode() {
      if (selectedNode) {
        const name = prompt('è¯·è¾“å…¥èŠ‚ç‚¹åç§°:', 'New Node');
        if (name) {
          addNode(name, selectedNode);
        }
      } else {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹');
      }
    }

    // æœç´¢èŠ‚ç‚¹
    function searchNode() {
      const searchTerm = prompt('è¯·è¾“å…¥è¦æœç´¢çš„èŠ‚ç‚¹åç§°:');
      if (searchTerm) {
        const foundNode = treeNodes.find(node =>
          node.name.toLowerCase().includes(searchTerm.toLowerCase())
        );

        if (foundNode) {
          selectNode(foundNode);
          log(`ğŸ” æ‰¾åˆ°èŠ‚ç‚¹: ${foundNode.name} (ID: ${foundNode.id})`);
        } else {
          log(`âŒ æœªæ‰¾åˆ°åŒ…å« "${searchTerm}" çš„èŠ‚ç‚¹`);
        }
      }
    }

    // åˆ é™¤èŠ‚ç‚¹
    function deleteNode() {
      if (selectedNode) {
        // åˆ é™¤æ‰€æœ‰å­èŠ‚ç‚¹
        function deleteChildren(node) {
          node.children.forEach(child => {
            deleteChildren(child);
            const index = treeNodes.indexOf(child);
            if (index > -1) {
              treeNodes.splice(index, 1);
              scene.remove(child.mesh);
            }
          });
        }

        deleteChildren(selectedNode);

        // ä»çˆ¶èŠ‚ç‚¹ä¸­ç§»é™¤
        if (selectedNode.parent) {
          selectedNode.parent.removeChild(selectedNode);
        }

        // ä»åœºæ™¯ä¸­ç§»é™¤
        scene.remove(selectedNode.mesh);

        // ä»æ•°ç»„ä¸­ç§»é™¤
        const index = treeNodes.indexOf(selectedNode);
        if (index > -1) {
          treeNodes.splice(index, 1);
        }

        log(`ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹: ${selectedNode.name} (ID: ${selectedNode.id})`);
        selectedNode = null;
        updateTreePositions();
        updateStats();
      } else {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹');
      }
    }

    // é‡ç½®æ ‘
    function resetTree() {
      treeNodes.forEach(node => {
        if (node.mesh) {
          scene.remove(node.mesh);
        }
      });
      treeNodes = [];
      selectedNode = null;
      nodeIdCounter = 0;
      updateStats();
      log('ğŸ”„ æ ‘å·²é‡ç½®');
    }

    // å¯¼å‡ºæ ‘
    function exportTree() {
      const treeData = {
        nodes: treeNodes.map(node => ({
          id: node.id,
          name: node.name,
          level: node.level,
          parentId: node.parent ? node.parent.id : null,
          children: node.children.map(child => child.id)
        })),
        totalNodes: treeNodes.length,
        maxLevel: Math.max(...treeNodes.map(node => node.level))
      };

      const dataStr = JSON.stringify(treeData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);

      const link = document.createElement('a');
      link.href = url;
      link.download = 'tree-data.json';
      link.click();

      log('ğŸ’¾ æ ‘æ•°æ®å·²å¯¼å‡º');
    }

    // é€‰æ‹©èŠ‚ç‚¹
    function selectNode(node) {
      // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
      if (selectedNode && selectedNode.mesh) {
        selectedNode.mesh.material.color.setHex(selectedNode.level === 0 ? 0x4ecdc4 : 0x45b7d1);
      }

      // é€‰æ‹©æ–°èŠ‚ç‚¹
      selectedNode = node;
      if (node.mesh) {
        node.mesh.material.color.setHex(0xff6b6b);
      }

      updateStats();
    }

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    function updateStats() {
      document.getElementById('nodeCount').textContent = treeNodes.length;
      document.getElementById('levelCount').textContent = treeNodes.length > 0 ? Math.max(...treeNodes.map(node => node.level)) : 0;
      document.getElementById('selectedNode').textContent = selectedNode ? selectedNode.name : '-';
    }

    // æ—¥å¿—å‡½æ•°
    function log(message, type = 'info') {
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry log-${type}`;
      logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logContainer.appendChild(logEntry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
    function onMouseClick(event) {
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
      mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(scene.children.filter(child => child.userData.node));

      if (intersects.length > 0) {
        const clickedNode = intersects[0].object.userData.node;
        selectNode(clickedNode);
        log(`ğŸ‘† é€‰ä¸­èŠ‚ç‚¹: ${clickedNode.name} (ID: ${clickedNode.id})`);
      }
    }

    // æ¸²æŸ“å¾ªç¯
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // åˆå§‹åŒ–
    function init() {
      initThreeJS();

      // æ·»åŠ äº‹ä»¶ç›‘å¬
      renderer.domElement.addEventListener('click', onMouseClick);

      // æ·»åŠ åˆå§‹èŠ‚ç‚¹
      addNode('Root');
      addNode('Child 1', treeNodes[0]);
      addNode('Child 2', treeNodes[0]);
      addNode('Grandchild 1', treeNodes[1]);

      // å¼€å§‹æ¸²æŸ“å¾ªç¯
      animate();

      log('ğŸ‰ Tree.js Demo åˆå§‹åŒ–å®Œæˆï¼');
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    window.addEventListener('load', init);
  </script>
</body>

</html>
