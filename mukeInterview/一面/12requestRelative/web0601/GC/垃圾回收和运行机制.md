## 垃圾回收

js 自动垃圾回收的语言 V8
垃圾回收 GC  
不要需要的数据** 垃圾数据** =》 回收 =》 释放内存空间

问题：
垃圾数据具体是怎么产生的呢？
js  
基本数据类型 栈空间
引用数据类型 堆空间
C mallco 函数分配内存， free 函数

```js
var test = {
  msg: {
    a: {}
  }
}
test.msg.a = [1, 2, 3]
```

可达性
v8 垃圾回收器 定期

- 开销比较大
- GC 会阻塞 js 执行

### 标记清除法 mark-sweep

标记： 标记所有活动对象

清除：没有标记的对象销毁

通过 GC ROOT 遍历到的对象，我们对象是可达到 对象 =》 活动对象
通过 GC ROOT 没有遍历到的对象 ，不可达的，可能会被回收， 非活动对象

二进制为 1 表示活动对象 0 表示非活动对象

过程

1. 所有的遍历加上一个标记，全部标记为 0
2. 各个根对象开始遍历， 把不是垃圾的节点 1
3. 清理操作， 把 0 清除，销毁
4. 内存对象重新修改为 0 等待下一轮回收

优点： 简单
缺点：
内存中会有大量的不连续的空间， 会产生**内存碎片**

三种分配策略

1. **first-fit 大于等于的块**
2. best-fit 最适合的块
3. worst-fit 最大的块，切成两部分 一部分分配给新的对象

效率考虑

缺点：

1. 内存碎片
2. 效率低 On

标记整理

### 引用计数法

- 引用的次数 1
- 同一个值又被赋值给另一个值， 引用次数 + 1
- 如果变量的值被其他的值覆盖了 - 1
- 引用次数 为 0

```js
let a = new Object() 1 + 1 - 1 - 1 = 0
let b = a
a = null
b = null
```

有什么缺点？

```js
let a = new Object()  1 + 1 - 1
let b = new Object()  1 + 1 - 1
a.msg = b
b.msg = a
a = null
b = null
```

优点： 0 立即回收垃圾
缺点： 循环引用

### V8 内存管理

代际假说 两个特点：

- 第一个 存活时间比较短
- 第二个 存活时间比较长 比如 window DOM webapi

#### 分代式垃圾回收机制

新生代：存活时间比较短对象
老生代 存活时间比较长对象

##### 新生代

1 - 8M  
scavenge 算法

将新生代拆分

- 使用区
- 空闲区

晋升老生代

- 多次赋值之后依然存活的，
- 新生代空间占用超过 25% 晋升老生代

##### 老生代

- 对象占用空间大
- 存活时间长的

标记 - 清除

标记整理
**全停顿**
js =》 标记 、清理、整理 =》 js
**并行回收**
**增量回收**

- 垃圾回收可以随时被暂停和重启 保存当时的一个扫描结果，
- 暂停、如果被 js 修改了 垃圾回收器能不能正确的处理

没有增量 V8 黑色和白色来标记数据

三色标记法

- 白色 表示没有被访问过
- 灰色 表示已经被访问过 但是 子节点没有被访问完，当前的节点
- 黑色 表示 访问过 子节点也访问完了

不能让黑色节点指向白色节点
写屏障机制 ： 当黑色节点指向白色节点时， 会把白色节点标记为灰色

并发回收
吞吐量

#### 内存泄露

不正当的使用闭包
隐形的全局变量
Map Set => WeakMap WeakSet

## 运行机制

进程：CPU 资源分配的最小单位
一个进程就是一个程序的运行实例 运行环境

线程：CPU 调度的最小单位
一个进程可以有多个线程，至少有一个线程 主线程

js 为什么是单线程的？
worker 执行 js 主线程
子线程是受主线程控制的

Chrome 浏览器

- 浏览器进程

  - 页面的显示、
  - 用户交互
  - 子进程管理

- GPU 进程
  - 3D css 效果
- 渲染进程
- 网络进程
- 插件进程

渲染进程
主线程

GUI 渲染

- HTML DOM
- CSS cssom
- 布局
- 绘制
- 合成
- repaint reflow
  js 引擎 - 解析 js 运行代码 - js 任务队列
  事件触发线程 - 负责准备好的事件交给 js 引擎 - 控制事件循环 task queue - 事件的回调依次的加入到 task queue 中
  定时触发线程 - setTimeout setInterval
  异步请求线程 - prmomise fetch ajax

GUI 渲染线程 js 引擎线程 互斥

### 事件循环

什么是事件循环？

js 同步任务 异步任务

宏任务

- js
- setTimeout setInterval
- setImmediate
- requestAnimationFrame
- I/O 操作
- UI 交互事件
- 消息队列的事件

宏任务 =》 GUI 渲染 =》 宏任务

微任务

- promise
- MutationObserver
  宏任务中的工作线

宏任务 =》 微任务 =》 gui -> 宏任务

```js
console.log(1)

queueMicrotask(() => {
  console.log(2)
})

Promise.resolve().then(() => console.log(3))

setTimeout(() => {
  console.log(4)
})
```

Node 事件循环

定时器：

- setTimeout
- setInterval
  I/O
- 文件读写
- 网络请求

node

- setImmediate

poll 阶段
队列是空

process.nextTick  
微队列
promise .then

为什么要有微任务
每个宏任务在执行的时候，V8 栈，

微任务 一个需要异步执行的函数， 在主函数执行结束之后，当前的宏任务结束之前

主线程执行消息队列中宏任务，没办法对精度和实时性要求高的场景胜任，微任务的设计可以在实时性和效率之间做个权衡

增量
