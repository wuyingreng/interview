# 跳跃游戏算法 - curIndex 和 nextIndex 详解

## 核心概念理解

### curIndex（当前跳跃边界）
- **含义**: 当前这一跳能到达的最远位置
- **作用**: 标记当前跳跃范围的边界线
- **触发条件**: 当 `i === curIndex` 时，说明已经遍历完当前跳跃范围，**必须**进行下一次跳跃

### nextIndex（下一跳最远距离）
- **含义**: 在当前跳跃范围内，下一跳能到达的最远位置
- **作用**: 记录在当前跳跃范围内探索到的最优下一跳位置
- **更新规则**: `nextIndex = Math.max(nums[i] + i, nextIndex)`

## 图解说明

```
nums = [2,3,1,1,4]
索引    0 1 2 3 4

初始状态:
curIndex = 0 (当前跳跃边界)
nextIndex = 0 (下一跳最远距离)
```

## 详细执行过程

### 第1轮循环 (i = 0)
```
当前位置: i = 0, nums[0] = 2
从位置0可以跳到: 位置1 或 位置2

nextIndex = max(2+0, 0) = 2  // 从位置0跳，最远能到位置2
i === curIndex (0) ✓        // 到达边界，必须跳跃！

跳跃发生:
curIndex = 2     // 更新边界到位置2
steps = 1        // 跳跃次数+1
```

### 第2轮循环 (i = 1)
```
当前位置: i = 1, nums[1] = 3
从位置1可以跳到: 位置2, 3, 4

nextIndex = max(3+1, 2) = 4  // 从位置1跳，最远能到位置4
i === curIndex (2) ✗         // 还没到边界，继续探索
```

### 第3轮循环 (i = 2)
```
当前位置: i = 2, nums[2] = 1
从位置2可以跳到: 位置3

nextIndex = max(1+2, 4) = 4  // 从位置2跳，最远还是位置4
i === curIndex (2) ✓         // 到达边界，必须跳跃！

跳跃发生:
curIndex = 4     // 更新边界到位置4
steps = 2        // 跳跃次数+1
```

### 第4轮循环 (i = 3)
```
当前位置: i = 3, nums[3] = 1
从位置3可以跳到: 位置4

nextIndex = max(1+3, 4) = 4  // 从位置3跳，最远还是位置4
i === curIndex (4) ✗         // 还没到边界，但已经可以到达终点
```

## 关键理解点

### 1. 边界概念
- `curIndex` 就像一道"边界线"
- 当遍历到这条边界线时，**必须**进行下一次跳跃
- 这保证了我们用最少的跳跃次数

### 2. 贪心策略
- 在每个跳跃范围内，我们不断更新 `nextIndex`
- `nextIndex` 记录的是在当前范围内能找到的最优下一跳位置
- 这样确保每次跳跃都是最优的

### 3. 算法精髓
```javascript
// 伪代码逻辑
for (当前范围内的每个位置) {
    更新下一跳的最远距离
    if (到达当前边界) {
        进行跳跃，更新新的边界
        步数+1
    }
}
```

## 直观类比

想象你在玩跳格子游戏：
- **curIndex**: 你当前这一跳的"安全区域"边界
- **nextIndex**: 你在安全区域内观察到的下一跳最远能到的地方
- 当你走到安全区域边界时，必须跳到下一个安全区域

这样，你总是能用最少的跳跃次数到达终点！ 