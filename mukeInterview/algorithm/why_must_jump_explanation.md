# 为什么当 i === curIndex 时必须跳跃？

## 核心原因：到达了当前跳跃范围的边界

### 理解边界概念

`curIndex` 表示**当前这一跳能够到达的最远位置**。当 `i === curIndex` 时，意味着：
- 我们已经遍历完了当前跳跃范围内的所有位置
- 如果不跳跃，就无法继续向前移动了
- **必须**进行下一次跳跃才能继续前进

## 直观例子

### 例子1：nums = [2,3,1,1,4]

```
位置: 0 1 2 3 4
值:   2 3 1 1 4
```

**第一次跳跃时机：**
```
初始: curIndex = 0, i = 0
当 i = 0 时：
- i === curIndex (0) ✓  
- 含义：我们在位置0，这是当前跳跃范围的边界
- 如果不跳：无法访问位置1, 2, 3, 4
- 必须跳：才能扩展可达范围
```

**第二次跳跃时机：**
```
第一跳后: curIndex = 2, 继续遍历
当 i = 2 时：
- i === curIndex (2) ✓
- 含义：我们已遍历完范围[0,1,2]内的所有位置
- 如果不跳：无法访问位置3, 4
- 必须跳：才能到达终点
```

## 更清晰的例子

### 例子2：nums = [1,1,1,1]

```
位置: 0 1 2 3
值:   1 1 1 1
```

**执行过程：**
```
i=0: curIndex=0, i===curIndex ✓ → 必须跳！更新curIndex=1
i=1: curIndex=1, i===curIndex ✓ → 必须跳！更新curIndex=2  
i=2: curIndex=2, i===curIndex ✓ → 必须跳！更新curIndex=3
```

**为什么每次都必须跳？**
- 每个位置只能跳1步
- 如果在位置0不跳，永远到不了位置1
- 如果在位置1不跳，永远到不了位置2
- 以此类推...

## 算法逻辑解释

### 核心思想：分层遍历

```javascript
// 算法本质上是在做这样的事情：
第0层: [位置0] → 跳跃 → 第1层
第1层: [位置1, 位置2, ...] → 跳跃 → 第2层  
第2层: [位置x, 位置y, ...] → 跳跃 → 第3层
...
```

### 边界触发机制

```javascript
for(let i = 0; i < nums.length - 1; i++) {
    nextIndex = Math.max(nums[i] + i, nextIndex)
    
    if(i === curIndex) {  // 到达当前层的边界
        // 必须跳到下一层，否则无法继续前进
        curIndex = nextIndex  
        steps++
    }
}
```

## 如果不跳会怎样？

### 反例演示

假设我们修改算法，不在边界处跳跃：

```javascript
// 错误的算法
var jumpWrong = function(nums) {
    let curIndex = 0
    let nextIndex = 0
    let steps = 0
    
    for(let i = 0; i < nums.length - 1; i++) {
        nextIndex = Math.max(nums[i] + i, nextIndex)
        // 假设我们不在边界处跳跃
        // if(i === curIndex) {  // 注释掉这个条件
        //     curIndex = nextIndex
        //     steps++
        // }
    }
    return steps  // 永远返回0，因为从未跳跃！
}
```

**结果**: 算法永远不会增加步数，无法正确计算最少跳跃次数。

## 本质理解

### 贪心策略的体现

```
当前跳跃范围: [start, curIndex]
下一跳最优范围: [curIndex+1, nextIndex]

当遍历到curIndex时：
- 已经探索完当前范围内的所有可能性
- 找到了下一跳的最优位置(nextIndex)
- 必须执行跳跃来进入下一个范围
```

## 总结

**为什么必须跳？**
1. **边界限制**: `curIndex` 是当前跳跃能力的边界
2. **前进需要**: 超越边界必须通过跳跃
3. **最优时机**: 此时已找到最优的下一跳位置
4. **算法保证**: 这样能确保用最少步数到达终点

**类比**: 就像爬楼梯，当你爬到当前楼层的最高点时，必须跳到下一个楼层才能继续往上爬！ 