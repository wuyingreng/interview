# 新晋打包工具

前端模块工具的发展

- 09 commonjs node
- 2011 requirejs 1.0 客户端 异步加载模块 AMD 规范
- 2013 grunt gulp
- 2014 umd
- 2014 6to5 => babel es6+ 词法分析 语法分析 ast =》 transform =》 new ast => generate code
- 2014 webpack 第一个稳定版本
- 2015 Es6 规范正式发布
- 2015 rollup 基于 es6 模块化 tree shaking
- 2017 parcel
- 2019 snowpack
- 2020 esm http2 支持 bundleless 思路开始出现 esbuild
- 2021 vite

### 总结

- 初版工具
- webpack 基石
- 基于 webpack 改进的工具
- 突破 js 语言特性的工具 esbuild snowpack rspack
- 基于 es module 的 bundleless 工具

## grunt

自动化的配置工具集

```js
'use strict'
module.exports = function (grunt) {
  // 构建的初始化配置
  grunt.initConfig({
    /* 配置具体任务 */
    pkg: grunt.file.readJSON('package.json'),
    dirs: {
      src: 'path',
      dest: 'dest/<%= pkg.name %>/<%= pkg.version %>',
    },
    // clean任务（删除dest/test_grunt/0.0.1 目录下非min的文件）
    clean: {
      js: ['<%= dirs.dest %>/*.js', '!<%= dirs.dest %>/*.min.js'],
      css: ['<%= dirs.dest %>/*.css', '!<%= dirs.dest %>/*.min.css'],
    },
    // copy任务（拷贝path目录下的文件到dest目录）
    copy: {
      main: {
        files: [
          // includes files within path
          {
            expand: true,
            src: ['path/*'],
            dest: '<%= dirs.dest %>/',
            filter: 'isFile',
          },
        ],
      },
    },
    // concat任务（将dest目录下的a.js和b.js合并为built.js）
    concat: {
      options: {
        separator: '\n',
      },
      concatCSS: {
        src: ['<%= dirs.dest %>/a.css', '<%= dirs.dest %>/path/b.css'],
        dest: '<%= dirs.dest %>/built.css',
      },
      concatJS: {
        src: ['<%= dirs.dest %>/a.js', '<%= dirs.dest %>/b.js'],
        dest: '<%= dirs.dest %>/built.js',
      },
    },
    // cssmin任务（压缩css）
    cssmin: {
      target: {
        files: [
          {
            expand: true,
            cwd: '<%= dirs.dest %>',
            src: ['*.css', '!*.min.css'],
            dest: '<%= dirs.dest %>',
            ext: '.min.css',
          },
        ],
      },
    },
    // uglify任务（压缩js）
    uglify: {
      options: {
        mangle: {
          except: ['jQuery', 'Backbone'],
        },
      },
      my_target: {
        files: {
          '<%= dirs.dest %>/bulit.min.js': ['<%= dirs.dest %>/*.js'],
        },
      },
    },
  })

  // 载入要使用的插件
  grunt.loadNpmTasks('grunt-contrib-clean')
  grunt.loadNpmTasks('grunt-contrib-copy')
  grunt.loadNpmTasks('grunt-contrib-concat')
  grunt.loadNpmTasks('grunt-contrib-cssmin')
  grunt.loadNpmTasks('grunt-contrib-uglify')

  // 注册刚配置好的任务
  grunt.registerTask('cls', ['clean'])
  grunt.registerTask('cpy', ['copy'])
  grunt.registerTask('con', ['concat'])
  grunt.registerTask('cmpCSS', ['cssmin'])
  grunt.registerTask('cmpJS', ['uglify'])

  grunt.registerTask('default', ['copy', 'concat', 'cssmin', 'uglify', 'clean'])
}
```

多个 less 进行预编译 压缩等操作

读取 less 文件 =》 编译 css =》 存到磁盘 =》 读取 css =》 压缩处理 =》 存到磁盘

## gulp

基于 task 驱动执行

```js
var gulp = require('gulp')
var pug = require('gulp-pug')
var less = require('gulp-less')
var minifyCSS = require('gulp-csso')

gulp.task('html', function () {
  return gulp
    .src('client/templates/*.pug')
    .pipe(pug())
    .pipe(gulp.dest('build/html'))
})

gulp.task('css', function () {
  return gulp
    .src('client/templates/*.less')
    .pipe(less())
    .pipe(minifyCSS())
    .pipe(gulp.dest('build/css'))
})

gulp.task('default', ['html', 'css'])
```

多个 less 进行预编译 压缩等操作

读取 less 编译为 css 压缩处理 存到磁盘

## webpack

## 基于 webpack 改进的构建工具

### rollup

- 更轻量
- 配置相对简单 一般用于类库的编写（js 库开发）
- 可以生成到指定环境 umd / commonjs / es vue react angular
- ES 模块的静态分析 tree shakding
- 构建速度快于 webpack

### parcel

- 完全零配置
- 构建速度快
- 适用于小型简单的项目 定制化需求比较高 建议使用 webpack 等其他的工具 社区资源丰富

## 突破 js 语言特性的构建工具

### SWC

SWC =》 babel ast loader plugin

speedy web compiler
compiler + bundler rust 实现

- 性能突出 对代码转换速度快

@swc/cli @swc/core

swc-loader => babel-loader

```js
import { readFileSync } from 'fs'
import { transform } from '@swc/core'

const run = async () => {
  const code = readFileSync('./source.js', 'utf-8')
  const result = await transform(code, {
    filename: 'source.js',
  })
  // 输出编译后代码
  console.log(result.code)
}

run()
```

swc+webpack 提升 js 文件的编译效率

## esbuild

- 使用 go
- 多线程 多个线程之间可共享内存空间

js postmessage (worker)

- 速度快 无需缓存
- 支持 es6 commonjs 模块
- 支持 es6 模块支持 tree shaking
- 兼容 ts jsx 语法
- 支持 source map
- 支持插件

## 基于 esmodule 的 bundleless（no bundle）构建工具

- http2
  不再受请求并发数的限制
- 浏览器 ESM

###

- 浏览器支持 http2 我们不需要合并静态资源
- esm

## vite

特点：

- 热更新速度快
- 预构建 esbuild
- plugin
- 开发环境冷启动无需打包
- 优化 HMR

### vite 原理

- esbuild 预构建：commonjs umd => 转换为支持 esm
- vite 会将构建的依赖缓存 node_modules/.vite dependencies lockfile vite.confi.js 配置
  触发预构建
- 缓存 http max-age=31536000 强缓存

请求拦截
启动 koa 服务器

path

- @modules/loadsh

  - node_modules 找对应模块
  - esbuild 处理

- .vue
  - template 对模块处理
  - css 处理 css
  - js/ts 处理
- js ts esbuild

```js
// src/node/serverPluginModuleRewrite.ts

// 只取关键代码：
// Vite 使用 Koa 作为内置的服务器
// 如果请求的路径是 /index.html
if (ctx.path === '/index.html') {
  // ...
  const html = await readBody(ctx.body)
  ctx.body = html.replace(
    /(<script\b[^>]*>)([\s\S]*?)<\/script>/gm, // 正则匹配
    (_, openTag, script) => {
      // also inject __DEV__ flag
      const devFlag = hasInjectedDevFlag ? `` : devInjectionCode
      hasInjectedDevFlag = true
       // 替换 html 的 import 路径
      return `${devFlag}${openTag}${rewriteImports(
        script,
        '/index.html',
        resolver
      )}</script>`
    }
  )
  // ...
}

// 如果并没有在 script 标签内部直接写 import，而是用 src 的形式引用的话如下：

<script type="module" src="/main.js"></script>


// 只取关键代码：
if (
  ctx.response.is('js') &&
  // ...
) {
  // ...
  const content = await readBody(ctx.body)
  await initLexer
  // 重写 js 文件里的 import
  ctx.body = rewriteImports(
    content,
    ctx.url.replace(/(&|\?)t=\d+/, ''),
    resolver,
    ctx.query.t
  )
  // 写入缓存，之后可以从缓存中直接读取
  rewriteCache.set(content, ctx.body)
}

// 其中的替换逻辑用的是 es-module-lexer 来进行的语法分析获取 imports 数组，然后再做的替换。
```

```js
<template>
  <h1>Hello Vite + Vue 3!</h1>
  <p>Edit ./App.vue to test hot module replacement (HMR).</p>
  <p>
    <span>Count is: {{ count }}</span>
    <button @click="count++">increment</button>
  </p>
</template>

<script>
export default {
  data: () => ({ count: 0 }),
}
</script>

<style scoped>
h1 {
  color: #4fc08d;
}

h1, p {
  font-family: Arial, Helvetica, sans-serif;
}
</style>


// localhost:3000/App.vue
import { updateStyle } from "/@hmr"

// 抽出 script 逻辑
const __script = {
  data: () => ({ count: 0 }),
}

// 将 style 拆分成 /App.vue?type=style 请求，由浏览器继续发起请求获取样式
updateStyle("c44b8200-0", "/App.vue?type=style&index=0&t=1588490870523")
__script.__scopeId = "data-v-c44b8200" // 样式的 scopeId

// 将 template 拆分成 /App.vue?type=template 请求，由浏览器继续发起请求获取 render function
import { render as __render } from "/App.vue?type=template&t=1588490870523&t=1588490870523"
__script.render = __render // render 方法挂载，用于 createApp 时渲染
__script.__hmrId = "/App.vue" // 记录 HMR 的 id，用于热更新
__script.__file = "/XXX/web/vite-test/App.vue" // 记录文件的原始的路径，后续热更新能用到
export default __script


```

### 热更新

- connected 链接成功
- style-update
- js-update
- full-reload 网页重新刷新

```js
// Listen for messages
socket.addEventListener('message', async ({ data }) => {
  const payload = JSON.parse(data) as HMRPayload | MultiUpdatePayload
  if (payload.type === 'multi') {
    payload.updates.forEach(handleMessage)
  } else {
    handleMessage(payload)
  }
})

async function handleMessage(payload: HMRPayload) {
  const { path, changeSrcPath, timestamp } = payload as UpdatePayload
  console.log(path)
  switch (payload.type) {
    case 'connected':
      console.log(`[vite] connected.`)
      break
    case 'vue-reload':
      queueUpdate(
        import(`${path}?t=${timestamp}`)
          .catch((err) => warnFailedFetch(err, path))
          .then((m) => () => {
            __VUE_HMR_RUNTIME__.reload(path, m.default)
            console.log(`[vite] ${path} reloaded.`)
          })
      )
      break
    case 'vue-rerender':
      const templatePath = `${path}?type=template`
      import(`${templatePath}&t=${timestamp}`).then((m) => {
        __VUE_HMR_RUNTIME__.rerender(path, m.render)
        console.log(`[vite] ${path} template updated.`)
      })
      break
    case 'style-update':
      // check if this is referenced in html via <link>
      const el = document.querySelector(`link[href*='${path}']`)
      if (el) {
        el.setAttribute(
          'href',
          `${path}${path.includes('?') ? '&' : '?'}t=${timestamp}`
        )
        break
      }
      const importQuery = path.includes('?') ? '&import' : '?import'
      await import(`${path}${importQuery}&t=${timestamp}`)
      console.log(`[vite] ${path} updated.`)
      break
    case 'js-update':
      queueUpdate(updateModule(path, changeSrcPath, timestamp))
      break
    case 'custom':
      const cbs = customUpdateMap.get(payload.id)
      if (cbs) {
        cbs.forEach((cb) => cb(payload.customData))
      }
      break
    case 'full-reload':
      if (path.endsWith('.html')) {
        // if html file is edited, only reload the page if the browser is
        // currently on that page.
        const pagePath = location.pathname
        if (
          pagePath === path ||
          (pagePath.endsWith('/') && pagePath + 'index.html' === path)
        ) {
          location.reload()
        }
        return
      } else {
       location.reload()
      }
  }
}

watcher.on('change', async (file) => {
  const timestamp = Date.now() // 更新时间戳
  if (file.endsWith('.vue')) {
    handleVueReload(file, timestamp)
  } else if (file.endsWith('.js')) {
    handleJSReload(file, timestamp)
  }
})


async function handleVueReload(
    file: string,
    timestamp: number = Date.now(),
    content?: string
) {
  const publicPath = resolver.fileToRequest(file) // 获取文件的路径
  const cacheEntry = vueCache.get(file) // 获取缓存里的内容

  debugHmr(`busting Vue cache for ${file}`)
  vueCache.del(file) // 发生变动了因此之前的缓存可以删除

  const descriptor = await parseSFC(root, file, content) // 编译 Vue 文件

  const prevDescriptor = cacheEntry && cacheEntry.descriptor // 获取前一次的缓存

  if (!prevDescriptor) {
    // 这个文件之前从未被访问过（本次是第一次访问），也就没必要热更新
    return
  }

  // 设置两个标志位，用于判断是需要 reload 还是 rerender
  let needReload = false
  let needRerender = false

  // 如果 script 部分不同则需要 reload
  if (!isEqual(descriptor.script, prevDescriptor.script)) {
    needReload = true
  }

  // 如果 template 部分不同则需要 rerender
  if (!isEqual(descriptor.template, prevDescriptor.template)) {
    needRerender = true
  }

  const styleId = hash_sum(publicPath)
  // 获取之前的 style 以及下一次（或者说热更新）的 style
  const prevStyles = prevDescriptor.styles || []
  const nextStyles = descriptor.styles || []

  // 如果不需要 reload，则查看是否需要更新 style
  if (!needReload) {
    nextStyles.forEach((_, i) => {
      if (!prevStyles[i] || !isEqual(prevStyles[i], nextStyles[i])) {
        send({
          type: 'style-update',
          path: publicPath,
          index: i,
          id: `${styleId}-${i}`,
          timestamp
        })
      }
    })
  }

  // 如果 style 标签及内容删掉了，则需要发送 `style-remove` 的通知
  prevStyles.slice(nextStyles.length).forEach((_, i) => {
    send({
      type: 'style-remove',
      path: publicPath,
      id: `${styleId}-${i + nextStyles.length}`,
      timestamp
    })
  })

  // 如果需要 reload 发送 `vue-reload` 通知
  if (needReload) {
    send({
      type: 'vue-reload',
      path: publicPath,
      timestamp
    })
  } else if (needRerender) {
    // 否则发送 `vue-rerender` 通知
    send({
      type: 'vue-rerender',
      path: publicPath,
      timestamp
    })
  }
}

```

## rspack

v1.1

### 更好的兼容性

主要 webpack 生态 插件 生态

rspack 1.0 体积比较小

rspaxk 技术栈

- rspack 实现底层高性能 bundler
- rsbuild 快速构建 web 应用
- rslib 构建 library
- rspress 生成站点

### 与 webpack 相比

- rust

### vite

### turbopack
