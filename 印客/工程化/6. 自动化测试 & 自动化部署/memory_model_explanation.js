// 内存模型解释

console.log('=== 内存模型可视化 ===');

console.log(`
基本类型的内存模型：
┌─────────────┐    ┌─────────────┐
│  变量 a     │    │  变量 b     │
│  ┌─────┐    │    │  ┌─────┐    │
│  │  5  │    │    │  │  5  │    │
│  └─────┘    │    │  └─────┘    │
└─────────────┘    └─────────────┘
  独立存储          独立存储

引用类型的内存模型：
┌─────────────┐    ┌─────────────┐
│  变量 obj1  │    │  变量 obj2  │
│  ┌─────┐    │    │  ┌─────┐    │
│  │地址1│────┼────┼──│地址1│    │
│  └─────┘    │    │  └─────┘    │
└─────────────┘    │             │
                   │    ┌────────┴────────┐
                   │    │    堆内存       │
                   │    │  ┌─────────────┐│
                   │    │  │  对象数据    ││
                   │    │  │ {name:'Bob'} ││
                   │    │  └─────────────┘│
                   │    └─────────────────┘
                   └─────────────────────┘
`);

console.log('\n=== 您的代码内存模型 ===');

console.log(`
您的代码执行过程：

1. const testa = {};
   ┌─────────────┐
   │  变量 testa │
   │  ┌─────┐    │
   │  │地址1│────┼──┐
   │  └─────┘    │  │
   └─────────────┘  │
                     │
                     │  ┌─────────────┐
                     │  │    堆内存   │
                     │  │ ┌─────────┐ │
                     │  │ │   {}    │ │  ← 空对象
                     │  │ └─────────┘ │
                     │  └─────────────┘

2. testa[1] = 1;
   ┌─────────────┐
   │  变量 testa │
   │  ┌─────┐    │
   │  │地址1│────┼──┐
   │  └─────┘    │  │
   └─────────────┘  │
                     │
                     │  ┌─────────────┐
                     │  │    堆内存   │
                     │  │ ┌─────────┐ │
                     │  │ │{1: 1}   │ │  ← 同一个对象，内容改变
                     │  │ └─────────┘ │
                     │  └─────────────┘

关键点：
- testa 变量存储的内存地址没有改变
- 改变的是堆内存中对象的内容
- 这就是为什么两次打印结果不同的原因
`);

console.log('\n=== 实际验证 ===');

// 验证内存地址不变
const testa = {};
console.log('初始对象地址:', testa);
console.log('初始对象内容:', JSON.stringify(testa));

const addressBefore = testa;
testa[1] = 1;
const addressAfter = testa;

console.log('修改后对象地址:', testa);
console.log('修改后对象内容:', JSON.stringify(testa));
console.log('地址是否相同:', addressBefore === addressAfter); // true

console.log('\n=== 重新赋值 vs 修改属性 ===');

console.log(`
重新赋值的情况：
let obj = {x: 1};
let ref = obj;        // ref 指向同一个对象

obj = {x: 2};         // obj 指向新对象，ref 仍然指向旧对象

┌─────────────┐    ┌─────────────┐
│  变量 obj   │    │  变量 ref   │
│  ┌─────┐    │    │  ┌─────┐    │
│  │地址2│    │    │  │地址1│    │
│  └─────┘    │    │  └─────┘    │
└─────────────┘    └─────────────┘
       │                   │
       │                   │
       │  ┌─────────────┐  │  ┌─────────────┐
       │  │  新对象     │  │  │  旧对象     │
       │  │ {x: 2}     │  │  │ {x: 1}     │
       │  └─────────────┘  │  └─────────────┘
       └───────────────────┘

修改属性的情况：
let obj = {x: 1};
let ref = obj;        // ref 指向同一个对象

obj.x = 2;            // 修改同一个对象的属性

┌─────────────┐    ┌─────────────┐
│  变量 obj   │    │  变量 ref   │
│  ┌─────┐    │    │  ┌─────┐    │
│  │地址1│────┼────┼──│地址1│    │
│  └─────┘    │    │  └─────┘    │
└─────────────┘    │             │
                   │    ┌────────┴────────┐
                   │    │    堆内存       │
                   │    │  ┌─────────────┐│
                   │    │  │ {x: 2}     ││
                   │    │  └─────────────┘│
                   │    └─────────────────┘
                   └─────────────────────┘
`); 