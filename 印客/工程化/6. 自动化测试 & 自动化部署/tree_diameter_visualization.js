// 二叉树直径问题的可视化解释

console.log('=== 二叉树直径问题可视化 ===');

console.log(`
概念理解：

1. 什么是二叉树的直径？
   - 任意两个节点之间的最长路径长度
   - 这个路径可能不经过根节点
   - 直径是边的数量，不是节点数量

2. 关键洞察：
   - 直径 = 左子树深度 + 右子树深度
   - 每个节点都可能成为直径路径的"转折点"

示例1：简单二叉树
       1
      / \\
     2   3
    / \\
   4   5

直径分析：
- 节点1: 左深度=2, 右深度=1, 直径=2+1=3
- 节点2: 左深度=1, 右深度=1, 直径=1+1=2
- 节点3: 左深度=0, 右深度=0, 直径=0+0=0
- 节点4: 左深度=0, 右深度=0, 直径=0+0=0
- 节点5: 左深度=0, 右深度=0, 直径=0+0=0

最大直径 = 3 (经过节点1的路径: 4->2->1->3)

示例2：复杂二叉树
       1
      / \\
     2   3
    / \\
   4   5
  /     \\
 6       7

直径分析：
- 节点1: 左深度=3, 右深度=1, 直径=3+1=4
- 节点2: 左深度=2, 右深度=2, 直径=2+2=4
- 节点3: 左深度=0, 右深度=0, 直径=0+0=0
- 节点4: 左深度=1, 右深度=0, 直径=1+0=1
- 节点5: 左深度=0, 右深度=1, 直径=0+1=1
- 节点6: 左深度=0, 右深度=0, 直径=0+0=0
- 节点7: 左深度=0, 右深度=0, 直径=0+0=0

最大直径 = 4 (路径: 6->4->2->5->7 或 6->4->2->1->3)

算法执行流程：

1. 后序遍历（左右根）
2. 在每个节点：
   - 计算左子树深度
   - 计算右子树深度
   - 更新全局最大直径 = max(当前直径, 全局最大直径)
   - 返回当前节点深度 = max(左深度, 右深度) + 1

递归调用栈示例（示例1）：
dfs(1) -> dfs(2) -> dfs(4) -> dfs(5) -> dfs(3)
返回顺序：4->5->2->3->1

边界条件：
- 空节点返回深度0
- 叶子节点返回深度1

时间复杂度: O(n) - 每个节点访问一次
空间复杂度: O(h) - h是树的高度，递归调用栈深度
`);

console.log('\n=== 代码实现要点 ===');

console.log(`
关键代码解释：

1. 全局变量记录最大直径：
   let maxDiameter = 0;

2. 递归函数返回深度：
   function dfs(node) {
       if (!node) return 0;  // 边界条件
       
       let leftDepth = dfs(node.left);
       let rightDepth = dfs(node.right);
       
       // 更新最大直径
       maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);
       
       // 返回当前节点深度
       return Math.max(leftDepth, rightDepth) + 1;
   }

3. 为什么直径不加1？
   - 直径是边的数量
   - 左深度 + 右深度 = 从最左叶子到当前节点 + 从当前节点到最右叶子
   - 这就是经过当前节点的最长路径的边数

4. 为什么返回深度要加1？
   - 深度是节点数量
   - 当前节点深度 = 子树最大深度 + 当前节点
`);

console.log('\n=== 常见错误 ===');

console.log(`
1. 混淆直径和深度：
   - 直径：边的数量
   - 深度：节点的数量

2. 只在根节点计算直径：
   - 直径可能不经过根节点
   - 需要在每个节点都计算

3. 忘记更新全局最大值：
   - 需要在每个节点都更新 maxDiameter

4. 边界条件处理错误：
   - 空节点应该返回0，不是null或undefined
`); 