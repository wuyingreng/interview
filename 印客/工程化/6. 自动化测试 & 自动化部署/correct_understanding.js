// 正确的二叉树直径理解

console.log('=== 正确的理解 ===');

console.log(`
示例二叉树：
       1
      / \\
     2   3
    / \\
   4   5

节点深度分析：
- 节点4: 深度=1 (只有自己)
- 节点5: 深度=1 (只有自己)  
- 节点3: 深度=1 (只有自己)
- 节点2: 深度=2 (max(节点4深度, 节点5深度) + 1 = max(1,1) + 1 = 2)
- 节点1: 深度=3 (max(节点2深度, 节点3深度) + 1 = max(2,1) + 1 = 3)

直径分析：
- 节点1: 直径 = 左子树深度 + 右子树深度 = 2 + 1 = 3
  路径: 4->2->1->3 (3条边)
- 节点2: 直径 = 左子树深度 + 右子树深度 = 1 + 1 = 2
  路径: 4->2->5 (2条边)
- 其他节点: 直径 = 0 (没有左右子树)

最大直径 = 3
`);

console.log('\n=== 关键概念区分 ===');

console.log(`
1. 深度 (Depth)：
   - 定义：从当前节点到最远叶子节点的节点数量
   - 计算：max(左子树深度, 右子树深度) + 1
   - 单位：节点数量

2. 直径 (Diameter)：
   - 定义：任意两个叶子节点之间的最长路径长度
   - 计算：左子树深度 + 右子树深度
   - 单位：边的数量

3. 为什么直径 = 左深度 + 右深度？
   - 左深度：从当前节点到最左叶子的节点数
   - 右深度：从当前节点到最右叶子的节点数
   - 直径：从最左叶子经过当前节点到最右叶子的边数
   - 边数 = 节点数 - 1
   - 所以：直径 = (左深度-1) + (右深度-1) + 2 = 左深度 + 右深度
`);

console.log('\n=== 您的代码分析 ===');

console.log(`
您的代码：
const leftSonNodes = dfs(node.left);    // 左子树深度（节点数）
const rightSonNodes = dfs(node.right);  // 右子树深度（节点数）
const currentDiameter = leftSonNodes + rightSonNodes;  // 直径（边数）

为什么这样计算是正确的？

1. 左子树深度 = 从当前节点到最左叶子的节点数
2. 右子树深度 = 从当前节点到最右叶子的节点数  
3. 直径路径：最左叶子 -> 当前节点 -> 最右叶子
4. 边数计算：
   - 最左叶子到当前节点：左深度 - 1 条边
   - 当前节点到最右叶子：右深度 - 1 条边
   - 总边数：(左深度-1) + (右深度-1) = 左深度 + 右深度 - 2

但是！这里有个关键点：
- 如果左深度=0或右深度=0，说明没有对应的子树
- 此时直径计算需要特殊处理

正确的理解：
直径 = 左深度 + 右深度（当左右子树都存在时）
`);

console.log('\n=== 修正后的理解 ===');

console.log(`
正确的理解应该是：

1. 某个节点作为"转折点"，它对应的直径是：
   - 如果左右子树都存在：左子树深度 + 右子树深度
   - 如果只有左子树：左子树深度
   - 如果只有右子树：右子树深度
   - 如果是叶子节点：0

2. 一个节点为父问题服务，它返回的深度是：
   - max(左子树深度, 右子树深度) + 1
   - 这个深度表示从当前节点到最远叶子的节点数量

3. 为什么这样计算？
   - 深度用于计算父节点的直径
   - 直径用于更新全局最大值
   - 两者有不同的用途和计算方式
`); 