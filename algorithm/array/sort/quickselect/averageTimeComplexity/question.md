# 题目 中等复杂度的题目，看不懂的
215. 数组中的第K个最大元素
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
 
示例 1:
输入: [3,2,1,5,6,4], k = 2
输出: 5
示例 2:
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
 
提示：
1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104
这道题用JS怎么做，用到了算法中的哪些知识
并给出为什么时间复杂度是O(n)， 和空间复杂度是多少


# 题解
## 解题思路
要设计一个时间复杂度为 O(n) 的算法来找到数组中的第 k 个最大元素，你可以使用快速选择算法（Quickselect），它是快速排序（Quicksort）的一种变种。快速选择算法可以在未完全排序整个数组的情况下找到第 k 大（或小）的元素。

下面是用 JavaScript 实现快速选择算法的示例代码：
./index.js

## 算法解释：

快速选择算法的关键在于 partition 函数，它选择一个基准（pivot），然后重新排列数组，使得所有小于基准的元素都位于它的左边，所有大于或等于基准的元素都位于它的右边。partition 函数返回基准的最终位置。

算法的主体部分通过不断调整查找范围来确定第 k 小的元素（注意，由于数组是从 0 开始索引的，所以第 k 个最大元素对应于第 length - k 小的元素）。如果基准的最终位置小于目标位置 k，则在右边继续查找；如果大于 k，则在左边继续查找；如果正好等于 k，则找到了第 k 大的元素。

时间复杂度：

快速选择算法的平均时间复杂度是 O(n)，因为它类似于快速排序，但不需要完全排序整个数组，只需要局部排序直到找到第 k 大的元素。最坏情况下时间复杂度为 O(n^2)，但通过随机选择基准或使用三点中值法可以减少最坏情况的概率。

空间复杂度：

快速选择算法的空间复杂度是 O(1)，因为它是在原地修改数组，除了递归调用的栈空间外没有使用额外的空间。在上面的非递归实现中，我们没有使用递归，所以空间复杂度确实是 O(1)。

